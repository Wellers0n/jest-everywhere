import { CodeSurfer, CodeSurferColumns, Step } from "code-surfer";
import { github, vsDark } from "@code-surfer/themes";
import jestImg from "./images/jest.png";
import featureCoverageImg from "./images/feature-coverage.png";
import featureFastImg from "./images/feature-fast.png";
import snapshotExampleImg from "./images/snapshot-example.png";
import featureMockingImg from "./images/feature-mocking.png";
import testPyramidImg from "./images/test-pyramid.png";
import kentCDoddsImg from "./images/kent-c-dodds.png";
import loginScreenImg from "./images/login-screen.png";
import loginScreenRequiredInputImg from "./images/login-screen-required-input.png";
import loginScreenOnchangeInputImg from "./images/login-screen-onchange-input.png";
import swaggerApiImg from "./images/swagger-api.png";
import sessionModuleImg from "./images/session-module.png";
import { Intro } from "./components/Intro.js";

export const theme = vsDark;

# Jest everywhere

<img src={jestImg} width={300} height={300} alt="jest" />

---

<Intro />

---

# OVERVIEW

- Why jest ?
- How to test on the frontend ?
- How to test on backend ?

---

# Why jest ?

- Zero config
- Snapshots
- Fast and safe
- Code coverage
- Easy mocking
- Community

---

<CodeSurfer>

```json title="Zero config" subtitle="Nestjs jest config"
{
  "jest": {
    "moduleFileExtensions": ["js", "json", "ts"],
    "rootDir": "src",
    "testRegex": ".spec\\.ts$",
    "testPathIgnorePatterns": ["/node_modules/", "-e2e.spec.ts$"],
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": ["**/*.(t|j)s"],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "moduleNameMapper": {
      "^@/(.*)$": "<rootDir>/../src/$1" // absolute path
    }
  }
}
```

```diff 1[10:14],3:15

```

</CodeSurfer>

---

<CodeSurfer>

```js title="Snapshots" subtitle="React component example"
exports[`renders correctly 1`] = `
<a
  className="normal"
  href="http://www.facebook.com"
  onMouseEnter={[Function]}
  onMouseLeave={[Function]}
>
  Facebook
</a>
`;
```

</CodeSurfer>

---

# Snapshot example

<img
  src={snapshotExampleImg}
  width={1550}
  height={1550}
  alt="snapshot example"
/>

---

# Fast and safe

<img src={featureFastImg} width={1300} height={1300} alt="feature fast" />

---

# Code coverage

<img
  src={featureCoverageImg}
  width={1300}
  height={1300}
  alt="feature coverage"
/>

---

# Easy mocking

<img src={featureMockingImg} width={1300} height={1300} alt="Easy mocking" />

---

# Community

<img src={kentCDoddsImg} width={1300} height={1300} alt="Community" />

---

# It works with projects using

- TypeScript
- Node
- React
- Next.JS
- Angular
- Vue
- Nest.JS

---

# Test pyramid

<img src={testPyramidImg} width={1050} height={1000} alt="Community" />

---

# How to test in frontend

- What to test?
- How to test?
- Using Mock Service Worker (MSW)

---

# What to test?

<img src={loginScreenImg} width={1300} height={1300} alt="login screen" />

---

# What to test?

<img
  src={loginScreenRequiredInputImg}
  width={1300}
  height={1300}
  alt="login screen required input"
/>

---

# What to test?

<img
  src={loginScreenOnchangeInputImg}
  width={1300}
  height={1300}
  alt="login screen on change input"
/>

---

<CodeSurferColumns>

<Step>

```jsx title="What to test?"
<Stack
  height={"90vh"}
  width={"100%"}
  mb={3}
  display={"flex"}
  justifyContent={"center"}
  alignItems={"center"}
>
  <Stack
    component={"form"}
    display={"flex"}
    justifyContent={"center"}
    alignItems={"center"}
    width={{ lg: "25%", md: "40%", xs: "78%" }}
    onSubmit={handleSubmit(submit)}
  >
    <Typography
      mb={5}
      display={"flex"}
      alignItems={"center"}
      justifyContent={"center"}
      color={"primary"}
      variant={mobile ? "h5" : "h4"}
      textAlign={"center"}
    >
      Jest everywhere
    </Typography>
    <Stack
      width={"100%"}
      spacing={2}
      direction={{ xs: "column", sm: "column", md: "column" }}
    >
      <Input
        name={"email"}
        control={control}
        label={"Email"}
        rules={{
          required: "Email é obrigatório",
          pattern: {
            value: /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            message: "Digite um email válido",
          },
        }}
      />
      <Input
        name={"password"}
        control={control}
        label={"Senha"}
        type="password"
        rules={{
          required: "Senha é obrigatório",
          minLength: {
            value: 3,
            message: "Digite pelo menos 3 caracteres",
          },
        }}
      />
    </Stack>
    <Stack
      width={"100%"}
      mt={2}
      direction={"row"}
      sx={{ justifyContent: "space-between", alignItems: "center" }}
    >
      <Button
        disabled={isLoading}
        sx={{ height: 40, width: 160 }}
        variant="contained"
        type="submit"
      >
        {isLoading ? <CircularProgress color="primary" size={22} /> : "Entrar"}
      </Button>
      <Button variant="text" onClick={() => router.push("/register")}>
        Cadastrar
      </Button>
    </Stack>
  </Stack>
</Stack>
```

</Step>

<Step>

```jsx 17:27
<Stack
  height={"90vh"}
  width={"100%"}
  mb={3}
  display={"flex"}
  justifyContent={"center"}
  alignItems={"center"}
>
  <Stack
    component={"form"}
    display={"flex"}
    justifyContent={"center"}
    alignItems={"center"}
    width={{ lg: "25%", md: "40%", xs: "78%" }}
    onSubmit={handleSubmit(submit)}
  >
    <Typography
      mb={5}
      display={"flex"}
      alignItems={"center"}
      justifyContent={"center"}
      color={"primary"}
      variant={mobile ? "h5" : "h4"}
      textAlign={"center"}
    >
      Jest everywhere
    </Typography>
    <Stack
      width={"100%"}
      spacing={2}
      direction={{ xs: "column", sm: "column", md: "column" }}
    >
      <Input
        name={"email"}
        control={control}
        label={"Email"}
        rules={{
          required: "Email é obrigatório",
          pattern: {
            value: /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            message: "Digite um email válido",
          },
        }}
      />
      <Input
        name={"password"}
        control={control}
        label={"Senha"}
        type="password"
        rules={{
          required: "Senha é obrigatório",
          minLength: {
            value: 3,
            message: "Digite pelo menos 3 caracteres",
          },
        }}
      />
    </Stack>
    <Stack
      width={"100%"}
      mt={2}
      direction={"row"}
      sx={{ justifyContent: "space-between", alignItems: "center" }}
    >
      <Button
        disabled={isLoading}
        sx={{ height: 40, width: 160 }}
        variant="contained"
        type="submit"
      >
        {isLoading ? <CircularProgress color="primary" size={22} /> : "Entrar"}
      </Button>
      <Button variant="text" onClick={() => router.push("/register")}>
        Cadastrar
      </Button>
    </Stack>
  </Stack>
</Stack>
```

</Step>

<Step>

```jsx 33:57
<Stack
  height={"90vh"}
  width={"100%"}
  mb={3}
  display={"flex"}
  justifyContent={"center"}
  alignItems={"center"}
>
  <Stack
    component={"form"}
    display={"flex"}
    justifyContent={"center"}
    alignItems={"center"}
    width={{ lg: "25%", md: "40%", xs: "78%" }}
    onSubmit={handleSubmit(submit)}
  >
    <Typography
      mb={5}
      display={"flex"}
      alignItems={"center"}
      justifyContent={"center"}
      color={"primary"}
      variant={mobile ? "h5" : "h4"}
      textAlign={"center"}
    >
      Jest everywhere
    </Typography>
    <Stack
      width={"100%"}
      spacing={2}
      direction={{ xs: "column", sm: "column", md: "column" }}
    >
      <Input
        name={"email"}
        control={control}
        label={"Email"}
        rules={{
          required: "Email é obrigatório",
          pattern: {
            value: /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            message: "Digite um email válido",
          },
        }}
      />
      <Input
        name={"password"}
        control={control}
        label={"Senha"}
        type="password"
        rules={{
          required: "Senha é obrigatório",
          minLength: {
            value: 3,
            message: "Digite pelo menos 3 caracteres",
          },
        }}
      />
    </Stack>
    <Stack
      width={"100%"}
      mt={2}
      direction={"row"}
      sx={{ justifyContent: "space-between", alignItems: "center" }}
    >
      <Button
        disabled={isLoading}
        sx={{ height: 40, width: 160 }}
        variant="contained"
        type="submit"
      >
        {isLoading ? <CircularProgress color="primary" size={22} /> : "Entrar"}
      </Button>
      <Button variant="text" onClick={() => router.push("/register")}>
        Cadastrar
      </Button>
    </Stack>
  </Stack>
</Stack>
```

</Step>

<Step>

```jsx 65:75
<Stack
  height={"90vh"}
  width={"100%"}
  mb={3}
  display={"flex"}
  justifyContent={"center"}
  alignItems={"center"}
>
  <Stack
    component={"form"}
    display={"flex"}
    justifyContent={"center"}
    alignItems={"center"}
    width={{ lg: "25%", md: "40%", xs: "78%" }}
    onSubmit={handleSubmit(submit)}
  >
    <Typography
      mb={5}
      display={"flex"}
      alignItems={"center"}
      justifyContent={"center"}
      color={"primary"}
      variant={mobile ? "h5" : "h4"}
      textAlign={"center"}
    >
      Jest everywhere
    </Typography>
    <Stack
      width={"100%"}
      spacing={2}
      direction={{ xs: "column", sm: "column", md: "column" }}
    >
      <Input
        name={"email"}
        control={control}
        label={"Email"}
        rules={{
          required: "Email é obrigatório",
          pattern: {
            value: /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
            message: "Digite um email válido",
          },
        }}
      />
      <Input
        name={"password"}
        control={control}
        label={"Senha"}
        type="password"
        rules={{
          required: "Senha é obrigatório",
          minLength: {
            value: 3,
            message: "Digite pelo menos 3 caracteres",
          },
        }}
      />
    </Stack>
    <Stack
      width={"100%"}
      mt={2}
      direction={"row"}
      sx={{ justifyContent: "space-between", alignItems: "center" }}
    >
      <Button
        disabled={isLoading}
        sx={{ height: 40, width: 160 }}
        variant="contained"
        type="submit"
      >
        {isLoading ? <CircularProgress color="primary" size={22} /> : "Entrar"}
      </Button>
      <Button variant="text" onClick={() => router.push("/register")}>
        Cadastrar
      </Button>
    </Stack>
  </Stack>
</Stack>
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns>

<Step>

```jsx title="How to test?"
import { fireEvent, render, screen } from "@testing-library/react";
import Page from "../page";
import Wrapper from "@/test/Wrapper";
import { rest, server } from "@/test/server";
import { act } from "react-dom/test-utils";

const url = process.env.BASE_URL;

describe("login", () => {
  it("should render login screen", () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    expect(screen.getByText("Jest everywhere")).toBeInTheDocument();
  });
  it("should render require login inputs", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Email é obrigatório")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });
  it("should render require email valid", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");

    fireEvent.change(emailInput, { target: { value: "admin@" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Digite um email válido")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });

  it("should render success message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(200),
          ctx.json({
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Logado com sucesso!")).toBeInTheDocument();
  });

  it("should render error message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(400),
          ctx.json({
            access_token: null,
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Error ao logar!")).toBeInTheDocument();
  });
});
```

</Step>

<Step>

```jsx 1:7
import { fireEvent, render, screen } from "@testing-library/react";
import Page from "../page";
import Wrapper from "@/test/Wrapper";
import { rest, server } from "@/test/server";
import { act } from "react-dom/test-utils";

const url = process.env.BASE_URL;

describe("login", () => {
  it("should render login screen", () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    expect(screen.getByText("Jest everywhere")).toBeInTheDocument();
  });
  it("should render require login inputs", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Email é obrigatório")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });
  it("should render require email valid", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");

    fireEvent.change(emailInput, { target: { value: "admin@" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Digite um email válido")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });

  it("should render success message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(200),
          ctx.json({
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Logado com sucesso!")).toBeInTheDocument();
  });

  it("should render error message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(400),
          ctx.json({
            access_token: null,
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Error ao logar!")).toBeInTheDocument();
  });
});
```

</Step>

<Step>

```jsx 10:18
import { fireEvent, render, screen } from "@testing-library/react";
import Page from "../page";
import Wrapper from "@/test/Wrapper";
import { rest, server } from "@/test/server";
import { act } from "react-dom/test-utils";

const url = process.env.BASE_URL;

describe("login", () => {
  it("should render login screen", () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    expect(screen.getByText("Jest everywhere")).toBeInTheDocument();
  });
  it("should render require login inputs", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Email é obrigatório")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });
  it("should render require email valid", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");

    fireEvent.change(emailInput, { target: { value: "admin@" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Digite um email válido")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });

  it("should render success message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(200),
          ctx.json({
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Logado com sucesso!")).toBeInTheDocument();
  });

  it("should render error message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(400),
          ctx.json({
            access_token: null,
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Error ao logar!")).toBeInTheDocument();
  });
});
```

</Step>

<Step>

```jsx 19:34
import { fireEvent, render, screen } from "@testing-library/react";
import Page from "../page";
import Wrapper from "@/test/Wrapper";
import { rest, server } from "@/test/server";
import { act } from "react-dom/test-utils";

const url = process.env.BASE_URL;

describe("login", () => {
  it("should render login screen", () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    expect(screen.getByText("Jest everywhere")).toBeInTheDocument();
  });
  it("should render require login inputs", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Email é obrigatório")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });
  it("should render require email valid", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");

    fireEvent.change(emailInput, { target: { value: "admin@" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Digite um email válido")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });

  it("should render success message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(200),
          ctx.json({
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Logado com sucesso!")).toBeInTheDocument();
  });

  it("should render error message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(400),
          ctx.json({
            access_token: null,
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Error ao logar!")).toBeInTheDocument();
  });
});
```

</Step>

<Step>

```jsx 35:54
import { fireEvent, render, screen } from "@testing-library/react";
import Page from "../page";
import Wrapper from "@/test/Wrapper";
import { rest, server } from "@/test/server";
import { act } from "react-dom/test-utils";

const url = process.env.BASE_URL;

describe("login", () => {
  it("should render login screen", () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    expect(screen.getByText("Jest everywhere")).toBeInTheDocument();
  });
  it("should render require login inputs", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Email é obrigatório")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });
  it("should render require email valid", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");

    fireEvent.change(emailInput, { target: { value: "admin@" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Digite um email válido")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });

  it("should render success message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(200),
          ctx.json({
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Logado com sucesso!")).toBeInTheDocument();
  });

  it("should render error message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(400),
          ctx.json({
            access_token: null,
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Error ao logar!")).toBeInTheDocument();
  });
});
```

</Step>

<Step>

```jsx 55:88 title="Testing with MSW"
import { fireEvent, render, screen } from "@testing-library/react";
import Page from "../page";
import Wrapper from "@/test/Wrapper";
import { rest, server } from "@/test/server";
import { act } from "react-dom/test-utils";

const url = process.env.BASE_URL;

describe("login", () => {
  it("should render login screen", () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    expect(screen.getByText("Jest everywhere")).toBeInTheDocument();
  });
  it("should render require login inputs", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Email é obrigatório")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });
  it("should render require email valid", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");

    fireEvent.change(emailInput, { target: { value: "admin@" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Digite um email válido")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });

  it("should render success message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(200),
          ctx.json({
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Logado com sucesso!")).toBeInTheDocument();
  });

  it("should render error message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(400),
          ctx.json({
            access_token: null,
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Error ao logar!")).toBeInTheDocument();
  });
});
```

</Step>

<Step>

```jsx 89:120 title="Testing with MSW"
import { fireEvent, render, screen } from "@testing-library/react";
import Page from "../page";
import Wrapper from "@/test/Wrapper";
import { rest, server } from "@/test/server";
import { act } from "react-dom/test-utils";

const url = process.env.BASE_URL;

describe("login", () => {
  it("should render login screen", () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    expect(screen.getByText("Jest everywhere")).toBeInTheDocument();
  });
  it("should render require login inputs", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Email é obrigatório")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });
  it("should render require email valid", async () => {
    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");

    fireEvent.change(emailInput, { target: { value: "admin@" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Digite um email válido")).toBeInTheDocument();
    expect(screen.getByText("Senha é obrigatório")).toBeInTheDocument();
  });

  it("should render success message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(200),
          ctx.json({
            access_token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Logado com sucesso!")).toBeInTheDocument();
  });

  it("should render error message when login", async () => {
    server.use(
      rest.post(`${url}/session/signin`, async (req, res, ctx) => {
        return res(
          ctx.status(400),
          ctx.json({
            access_token: null,
          })
        );
      })
    );

    render(
      <Wrapper>
        <Page />
      </Wrapper>
    );

    const emailInput = screen.getByLabelText("Email");
    const passwordInput = screen.getByLabelText("Senha");

    fireEvent.change(emailInput, { target: { value: "admin@admin.com" } });
    fireEvent.change(passwordInput, { target: { value: "admin" } });

    const submitBtn = screen.getByText("Entrar");

    await act(() => {
      fireEvent.click(submitBtn);
    });

    expect(screen.getByText("Error ao logar!")).toBeInTheDocument();
  });
});
```

</Step>

</CodeSurferColumns>

---

# Best way to get an element?

- getByLabelText
- getByText
- getByDisplayValue
- getByPlaceholderText

---

# How to test on backend ?

- What to test?
- How to test?
- How to do e2e tests with docker ?

---

<CodeSurferColumns>

<Step>

```ts title="What to test ?" subtitle="session.controller.ts"
import { Body, Controller, HttpCode, HttpStatus, Post } from "@nestjs/common";
import { SessionService } from "./session.service";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import {
  ApiConflictResponse,
  ApiOkResponse,
  ApiTags,
  ApiUnauthorizedResponse,
} from "@nestjs/swagger";
import {
  AuthUnauthorizedResponse,
  AuthOkResponse,
  AuthConflictResponse,
} from "./swagger/auth.swagger";

@Controller("session")
@ApiTags("Session")
export class SessionController {
  constructor(private sessionService: SessionService) {}

  @ApiOkResponse({ type: AuthOkResponse })
  @ApiUnauthorizedResponse({ type: AuthUnauthorizedResponse })
  @HttpCode(HttpStatus.OK)
  @Post("signin")
  signIn(@Body() body: LoginBodyDTO) {
    const { email, password } = body;
    return this.sessionService.signIn({ email, password });
  }

  @ApiOkResponse({ type: AuthOkResponse })
  @ApiConflictResponse({ type: AuthConflictResponse })
  @HttpCode(HttpStatus.OK)
  @Post("register")
  register(@Body() body: RegisterBodyDTO) {
    const { email, password, name } = body;
    return this.sessionService.register({ name, email, password });
  }
}
```

</Step>

<Step>

```ts 20:20 title="Providers"
import { Body, Controller, HttpCode, HttpStatus, Post } from "@nestjs/common";
import { SessionService } from "./session.service";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import {
  ApiConflictResponse,
  ApiOkResponse,
  ApiTags,
  ApiUnauthorizedResponse,
} from "@nestjs/swagger";
import {
  AuthUnauthorizedResponse,
  AuthOkResponse,
  AuthConflictResponse,
} from "./swagger/auth.swagger";

@Controller("session")
@ApiTags("Session")
export class SessionController {
  constructor(private sessionService: SessionService) {}

  @ApiOkResponse({ type: AuthOkResponse })
  @ApiUnauthorizedResponse({ type: AuthUnauthorizedResponse })
  @HttpCode(HttpStatus.OK)
  @Post("signin")
  signIn(@Body() body: LoginBodyDTO) {
    const { email, password } = body;
    return this.sessionService.signIn({ email, password });
  }

  @ApiOkResponse({ type: AuthOkResponse })
  @ApiConflictResponse({ type: AuthConflictResponse })
  @HttpCode(HttpStatus.OK)
  @Post("register")
  register(@Body() body: RegisterBodyDTO) {
    const { email, password, name } = body;
    return this.sessionService.register({ name, email, password });
  }
}
```

</Step>

<Step>

```ts 25:30 title="Method"
import { Body, Controller, HttpCode, HttpStatus, Post } from "@nestjs/common";
import { SessionService } from "./session.service";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import {
  ApiConflictResponse,
  ApiOkResponse,
  ApiTags,
  ApiUnauthorizedResponse,
} from "@nestjs/swagger";
import {
  AuthUnauthorizedResponse,
  AuthOkResponse,
  AuthConflictResponse,
} from "./swagger/auth.swagger";

@Controller("session")
@ApiTags("Session")
export class SessionController {
  constructor(private sessionService: SessionService) {}

  @ApiOkResponse({ type: AuthOkResponse })
  @ApiUnauthorizedResponse({ type: AuthUnauthorizedResponse })
  @HttpCode(HttpStatus.OK)
  @Post("signin")
  signIn(@Body() body: LoginBodyDTO) {
    const { email, password } = body;
    return this.sessionService.signIn({ email, password });
  }

  @ApiOkResponse({ type: AuthOkResponse })
  @ApiConflictResponse({ type: AuthConflictResponse })
  @HttpCode(HttpStatus.OK)
  @Post("register")
  register(@Body() body: RegisterBodyDTO) {
    const { email, password, name } = body;
    return this.sessionService.register({ name, email, password });
  }
}
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns>

<Step>

```ts title="How to test ?" subtitle="session.controller.spec.ts"
import { SessionService } from "./session.service";
import { SessionController } from "./session.controller";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";

import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";

describe("Session controller", () => {
  let sessionController: SessionController;

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  const sessionMockResponse = {
    access_token: faker.string.uuid,
    message: faker.internet.emoji,
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [SessionController],
      providers: [
        {
          provide: SessionService,
          useValue: {
            signIn: jest.fn().mockResolvedValue(sessionMockResponse),
            register: jest.fn().mockResolvedValue(sessionMockResponse),
          },
        },
      ],
    }).compile();

    sessionController = app.get<SessionController>(SessionController);
  });

  it("should return a success signIn", async () => {
    const response = await sessionController.signIn(userMockSignIn);

    expect(response).toEqual(sessionMockResponse);
  });

  it("should return a success register", async () => {
    const response = await sessionController.register(userMockRegister);

    expect(response).toEqual(sessionMockResponse);
  });
});
```

</Step>

<Step>

```ts 11:26 title="Mocks"
import { SessionService } from "./session.service";
import { SessionController } from "./session.controller";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";

import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";

describe("Session controller", () => {
  let sessionController: SessionController;

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  const sessionMockResponse = {
    access_token: faker.string.uuid,
    message: faker.internet.emoji,
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [SessionController],
      providers: [
        {
          provide: SessionService,
          useValue: {
            signIn: jest.fn().mockResolvedValue(sessionMockResponse),
            register: jest.fn().mockResolvedValue(sessionMockResponse),
          },
        },
      ],
    }).compile();

    sessionController = app.get<SessionController>(SessionController);
  });

  it("should return a success signIn", async () => {
    const response = await sessionController.signIn(userMockSignIn);

    expect(response).toEqual(sessionMockResponse);
  });

  it("should return a success register", async () => {
    const response = await sessionController.register(userMockRegister);

    expect(response).toEqual(sessionMockResponse);
  });
});
```

</Step>

<Step>

```ts 28:43 title="beforeEach"
import { SessionService } from "./session.service";
import { SessionController } from "./session.controller";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";

import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";

describe("Session controller", () => {
  let sessionController: SessionController;

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  const sessionMockResponse = {
    access_token: faker.string.uuid,
    message: faker.internet.emoji,
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [SessionController],
      providers: [
        {
          provide: SessionService,
          useValue: {
            signIn: jest.fn().mockResolvedValue(sessionMockResponse),
            register: jest.fn().mockResolvedValue(sessionMockResponse),
          },
        },
      ],
    }).compile();

    sessionController = app.get<SessionController>(SessionController);
  });

  it("should return a success signIn", async () => {
    const response = await sessionController.signIn(userMockSignIn);

    expect(response).toEqual(sessionMockResponse);
  });

  it("should return a success register", async () => {
    const response = await sessionController.register(userMockRegister);

    expect(response).toEqual(sessionMockResponse);
  });
});
```

</Step>

<Step>

```ts 45:50 title="Signin test"
import { SessionService } from "./session.service";
import { SessionController } from "./session.controller";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";

import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";

describe("Session controller", () => {
  let sessionController: SessionController;

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  const sessionMockResponse = {
    access_token: faker.string.uuid,
    message: faker.internet.emoji,
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [SessionController],
      providers: [
        {
          provide: SessionService,
          useValue: {
            signIn: jest.fn().mockResolvedValue(sessionMockResponse),
            register: jest.fn().mockResolvedValue(sessionMockResponse),
          },
        },
      ],
    }).compile();

    sessionController = app.get<SessionController>(SessionController);
  });

  it("should return a success signIn", async () => {
    const response = await sessionController.signIn(userMockSignIn);

    expect(response).toEqual(sessionMockResponse);
  });

  it("should return a success register", async () => {
    const response = await sessionController.register(userMockRegister);

    expect(response).toEqual(sessionMockResponse);
  });
});
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns>

<Step>

```ts title="What to test ?" subtitle="session.service.ts"
import {
  Injectable,
  ConflictException,
  BadRequestException,
} from "@nestjs/common";
import { UsersService } from "../users/users.service";
import { JwtService } from "@nestjs/jwt";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";

@Injectable()
export class SessionService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async signIn(data: LoginBodyDTO) {
    const { email, password } = data;

    const user = await this.usersService.findByEmail({ email });

    if (!user) throw new BadRequestException("Email or password incorrect");

    const correctPassword = bcrypt.compareSync(password, user.password);

    if (!correctPassword) {
      throw new BadRequestException("Email or password incorrect");
    }

    const payload = { id: user.id, username: user.name };

    return {
      access_token: await this.jwtService.signAsync(payload, {
        secret: process.env.JWT_SECRET,
      }),
      message: "Login com sucesso",
    };
  }

  async register(data: RegisterBodyDTO) {
    const { email, name, password } = data;

    const userExist = await this.usersService.findByEmail({ email });

    if (userExist) throw new ConflictException("Usuário já existe");

    const user = await this.usersService.create({ email, name, password });

    const payload = { id: user.id, username: user.name };
    return {
      access_token: await this.jwtService.signAsync(payload, {
        secret: process.env.JWT_SECRET,
      }),
      message: "Registrado com sucesso",
    };
  }
}
```

</Step>

<Step>

```ts 15:16 title="Providers"
import {
  Injectable,
  ConflictException,
  BadRequestException,
} from "@nestjs/common";
import { UsersService } from "../users/users.service";
import { JwtService } from "@nestjs/jwt";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";

@Injectable()
export class SessionService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async signIn(data: LoginBodyDTO) {
    const { email, password } = data;

    const user = await this.usersService.findByEmail({ email });

    if (!user) throw new BadRequestException("Email or password incorrect");

    const correctPassword = bcrypt.compareSync(password, user.password);

    if (!correctPassword) {
      throw new BadRequestException("Email or password incorrect");
    }

    const payload = { id: user.id, username: user.name };

    return {
      access_token: await this.jwtService.signAsync(payload, {
        secret: process.env.JWT_SECRET,
      }),
      message: "Login com sucesso",
    };
  }

  async register(data: RegisterBodyDTO) {
    const { email, name, password } = data;

    const userExist = await this.usersService.findByEmail({ email });

    if (userExist) throw new ConflictException("Usuário já existe");

    const user = await this.usersService.create({ email, name, password });

    const payload = { id: user.id, username: user.name };
    return {
      access_token: await this.jwtService.signAsync(payload, {
        secret: process.env.JWT_SECRET,
      }),
      message: "Registrado com sucesso",
    };
  }
}
```

</Step>

<Step>

```ts 19:40 title="Method"
import {
  Injectable,
  ConflictException,
  BadRequestException,
} from "@nestjs/common";
import { UsersService } from "../users/users.service";
import { JwtService } from "@nestjs/jwt";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";

@Injectable()
export class SessionService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async signIn(data: LoginBodyDTO) {
    const { email, password } = data;

    const user = await this.usersService.findByEmail({ email });

    if (!user) throw new BadRequestException("Email or password incorrect");

    const correctPassword = bcrypt.compareSync(password, user.password);

    if (!correctPassword) {
      throw new BadRequestException("Email or password incorrect");
    }

    const payload = { id: user.id, username: user.name };

    return {
      access_token: await this.jwtService.signAsync(payload, {
        secret: process.env.JWT_SECRET,
      }),
      message: "Login com sucesso",
    };
  }

  async register(data: RegisterBodyDTO) {
    const { email, name, password } = data;

    const userExist = await this.usersService.findByEmail({ email });

    if (userExist) throw new ConflictException("Usuário já existe");

    const user = await this.usersService.create({ email, name, password });

    const payload = { id: user.id, username: user.name };
    return {
      access_token: await this.jwtService.signAsync(payload, {
        secret: process.env.JWT_SECRET,
      }),
      message: "Registrado com sucesso",
    };
  }
}
```

</Step>

</CodeSurferColumns>

---

<CodeSurferColumns>

<Step>

```ts title="How to test ?" subtitle="session.service.spec.ts"
import { SessionService } from "./session.service";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import { UsersService } from "../users/users.service";
import { BadRequestException, ConflictException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

describe("Session service", () => {
  let sessionService: SessionService;
  let usersService: UsersService;

  const userMock = {
    id: faker.number.int(),
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
    createdAt: faker.date.anytime(),
    updatedAt: faker.date.anytime(),
  };

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      providers: [
        SessionService,
        JwtService,
        {
          provide: UsersService,
          useValue: {
            findByEmail: jest.fn(),
            create: jest.fn(),
          },
        },
      ],
    }).compile();

    sessionService = app.get<SessionService>(SessionService);
    usersService = app.get<UsersService>(UsersService);
  });

  it("should return a success signIn", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = await sessionService.signIn(userMockSignIn);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Login com sucesso");
  });

  it("should return signIn with incorrect email", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return signIn with incorrect password", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(false);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return successful register", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    jest.spyOn(usersService, "create").mockImplementation(async () => userMock);

    const response = await sessionService.register(userMockRegister);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Registrado com sucesso");
  });

  it("should return an existing user", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.register(userMockRegister);

    await expect(response).rejects.toEqual(
      new ConflictException("Usuário já existe")
    );
  });
});
```

</Step>

<Step>

```ts 15:33 title="Mocks"
import { SessionService } from "./session.service";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import { UsersService } from "../users/users.service";
import { BadRequestException, ConflictException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

describe("Session service", () => {
  let sessionService: SessionService;
  let usersService: UsersService;

  const userMock = {
    id: faker.number.int(),
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
    createdAt: faker.date.anytime(),
    updatedAt: faker.date.anytime(),
  };

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      providers: [
        SessionService,
        JwtService,
        {
          provide: UsersService,
          useValue: {
            findByEmail: jest.fn(),
            create: jest.fn(),
          },
        },
      ],
    }).compile();

    sessionService = app.get<SessionService>(SessionService);
    usersService = app.get<UsersService>(UsersService);
  });

  it("should return a success signIn", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = await sessionService.signIn(userMockSignIn);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Login com sucesso");
  });

  it("should return signIn with incorrect email", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return signIn with incorrect password", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(false);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return successful register", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    jest.spyOn(usersService, "create").mockImplementation(async () => userMock);

    const response = await sessionService.register(userMockRegister);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Registrado com sucesso");
  });

  it("should return an existing user", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.register(userMockRegister);

    await expect(response).rejects.toEqual(
      new ConflictException("Usuário já existe")
    );
  });
});
```

</Step>

<Step>

```ts 35:52 title="beforeEach"
import { SessionService } from "./session.service";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import { UsersService } from "../users/users.service";
import { BadRequestException, ConflictException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

describe("Session service", () => {
  let sessionService: SessionService;
  let usersService: UsersService;

  const userMock = {
    id: faker.number.int(),
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
    createdAt: faker.date.anytime(),
    updatedAt: faker.date.anytime(),
  };

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      providers: [
        SessionService,
        JwtService,
        {
          provide: UsersService,
          useValue: {
            findByEmail: jest.fn(),
            create: jest.fn(),
          },
        },
      ],
    }).compile();

    sessionService = app.get<SessionService>(SessionService);
    usersService = app.get<UsersService>(UsersService);
  });

  it("should return a success signIn", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = await sessionService.signIn(userMockSignIn);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Login com sucesso");
  });

  it("should return signIn with incorrect email", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return signIn with incorrect password", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(false);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return successful register", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    jest.spyOn(usersService, "create").mockImplementation(async () => userMock);

    const response = await sessionService.register(userMockRegister);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Registrado com sucesso");
  });

  it("should return an existing user", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.register(userMockRegister);

    await expect(response).rejects.toEqual(
      new ConflictException("Usuário já existe")
    );
  });
});
```

</Step>

<Step>

```ts 53:65 title="Success sign in"
import { SessionService } from "./session.service";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import { UsersService } from "../users/users.service";
import { BadRequestException, ConflictException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

describe("Session service", () => {
  let sessionService: SessionService;
  let usersService: UsersService;

  const userMock = {
    id: faker.number.int(),
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
    createdAt: faker.date.anytime(),
    updatedAt: faker.date.anytime(),
  };

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      providers: [
        SessionService,
        JwtService,
        {
          provide: UsersService,
          useValue: {
            findByEmail: jest.fn(),
            create: jest.fn(),
          },
        },
      ],
    }).compile();

    sessionService = app.get<SessionService>(SessionService);
    usersService = app.get<UsersService>(UsersService);
  });

  it("should return a success signIn", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = await sessionService.signIn(userMockSignIn);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Login com sucesso");
  });

  it("should return signIn with incorrect email", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return signIn with incorrect password", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(false);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return successful register", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    jest.spyOn(usersService, "create").mockImplementation(async () => userMock);

    const response = await sessionService.register(userMockRegister);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Registrado com sucesso");
  });

  it("should return an existing user", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.register(userMockRegister);

    await expect(response).rejects.toEqual(
      new ConflictException("Usuário já existe")
    );
  });
});
```

</Step>

<Step>

```ts 66:80 title="Error sign in"
import { SessionService } from "./session.service";
import { faker } from "@faker-js/faker";
import { Test, TestingModule } from "@nestjs/testing";
import * as bcrypt from "bcryptjs";
import { LoginBodyDTO } from "./dtos/login-body.dto";
import { RegisterBodyDTO } from "./dtos/register-body.dto";
import { UsersService } from "../users/users.service";
import { BadRequestException, ConflictException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

describe("Session service", () => {
  let sessionService: SessionService;
  let usersService: UsersService;

  const userMock = {
    id: faker.number.int(),
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
    createdAt: faker.date.anytime(),
    updatedAt: faker.date.anytime(),
  };

  const userMockSignIn: LoginBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
  };

  const userMockRegister: RegisterBodyDTO = {
    email: faker.internet.email(),
    password: faker.internet.password(),
    name: faker.internet.userName(),
  };

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      providers: [
        SessionService,
        JwtService,
        {
          provide: UsersService,
          useValue: {
            findByEmail: jest.fn(),
            create: jest.fn(),
          },
        },
      ],
    }).compile();

    sessionService = app.get<SessionService>(SessionService);
    usersService = app.get<UsersService>(UsersService);
  });

  it("should return a success signIn", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = await sessionService.signIn(userMockSignIn);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Login com sucesso");
  });

  it("should return signIn with incorrect email", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(true);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return signIn with incorrect password", async () => {
    bcrypt.compareSync = jest.fn().mockReturnValueOnce(false);

    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.signIn(userMockSignIn);

    await expect(response).rejects.toEqual(
      new BadRequestException("Email or password incorrect")
    );
  });

  it("should return successful register", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => null);

    jest.spyOn(usersService, "create").mockImplementation(async () => userMock);

    const response = await sessionService.register(userMockRegister);

    expect(response.access_token).toBeTruthy();
    expect(response.message).toBe("Registrado com sucesso");
  });

  it("should return an existing user", async () => {
    jest
      .spyOn(usersService, "findByEmail")
      .mockImplementation(async () => userMock);

    const response = sessionService.register(userMockRegister);

    await expect(response).rejects.toEqual(
      new ConflictException("Usuário já existe")
    );
  });
});
```

</Step>

</CodeSurferColumns>

---

docs:  
[codesurfer.pomb.us](https://codesurfer.pomb.us)
